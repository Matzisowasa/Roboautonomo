// --- 1. DEFINICIÓN DE PINES ---
// Servomotor MG996R (dirección)
Servo direccionServo;
const int SERVO_PIN = 3;
// DRIVER BTS7960 (motor principal)
const int RPWM = 6; // Adelante
const int LPWM = 5; // Reversa
const int R_EN = 4; // Habilitación
const int L_EN = 2;
// Sensores ultrasónicos HC-SR04
// Izquierda
const int TRIG_L = 9;
const int ECHO_L = 10;
// Derecha
const int TRIG_R = 11;
const int ECHO_R = 12;
// Frontal
const int TRIG_D = 7;
const int ECHO_D = 8;
// --- 2. CONSTANTES DE CALIBRACIÓN ---
const float Kp = 1.2; // Ganancia proporcional para corrección de
rumbo
// Servo
const int SERVO_CENTRO = 85;
const int SERVO_LIMITE_MAX = 110;
const int SERVO_LIMITE_MIN = 50;
// Motor
const int VELOCIDAD = 255;
const int RETROCESO_VEL = 255;
// Evitación de obstáculos
const float DISTANCIA_CHOQUE = 10.0;
const int TIEMPO_REVERSA = 250;
// --- 3. FUNCIÓN PARA LEER ULTRASÓNICO ---
float leerDistancia(int trigPin, int echoPin) {
digitalWrite(trigPin, LOW);
delayMicroseconds(2);
digitalWrite(trigPin, HIGH); // Pulso para activar medición
delayMicroseconds(10);
digitalWrite(trigPin, LOW);
long duracion = pulseIn(echoPin, HIGH, 25000);
float distancia = duracion * 0.034 / 2;
if (distancia > 200 || distancia <= 0) return 200; // Filtro básico
return distancia;
}
// --- 4. CONTROL DE MOVIMIENTO ---
void avanzar(int vel) {
analogWrite(RPWM, vel);
analogWrite(LPWM, 0);
}
void detener() {
analogWrite(RPWM, 0);
analogWrite(LPWM, 0);
}
void retroceder(int vel) {
analogWrite(RPWM, 0);
analogWrite(LPWM, vel);
}
// --- 5. CONFIGURACIÓN GENERAL DEL SISTEMA ---
void setup() {
delay(2000);
// Sensores
pinMode(TRIG_L, OUTPUT); pinMode(ECHO_L, INPUT);
pinMode(TRIG_R, OUTPUT); pinMode(ECHO_R, INPUT);
pinMode(TRIG_D, OUTPUT); pinMode(ECHO_D, INPUT);
// Motor
pinMode(RPWM, OUTPUT);
pinMode(LPWM, OUTPUT);
digitalWrite(R_EN, HIGH);
digitalWrite(L_EN, HIGH);
// Servo
direccionServo.attach(SERVO_PIN);
direccionServo.write(SERVO_CENTRO);
detener();
Serial.begin(9600);
}
// --- 6. BUCLE PRINCIPAL ---
void loop() {
// --- Lectura de sensores (obstáculos) ---
float distD = leerDistancia(TRIG_D, ECHO_D);
float distL = leerDistancia(TRIG_L, ECHO_L);
float distR = leerDistancia(TRIG_R, ECHO_R);
// --- EVITACIÓN DE OBSTÁCULO FRONTAL ---
// Si el obstáculo está muy cerca, se ejecuta una maniobra de
emergencia
if (distD < DISTANCIA_CHOQUE) {
detener();
delay(100);
// Retroceso breve para evitar colisión
retroceder(RETROCESO_VEL);
delay(TIEMPO_REVERSA);
detener();
delay(100);
// Giro mínimo para reorientar
direccionServo.write(SERVO_LIMITE_MIN);
retroceder(RETROCESO_VEL);
delay(500);
detener();
}
// --- CONTROL PROPORCIONAL DE RUMBO ---
else {
float error = distR - distL; // Diferencia lateral
int correccion = (int)(error * Kp);
int angulo = SERVO_CENTRO + correccion;
// Limitar ángulo para evitar daño al servo
if (angulo > SERVO_LIMITE_MAX) angulo =
SERVO_LIMITE_MAX;
if (angulo < SERVO_LIMITE_MIN) angulo = SERVO_LIMITE_MIN;
direccionServo.write(angulo);
avanzar(VELOCIDAD);
}
// Datos enviados por serial para depuración
Serial.print("DI: "); Serial.print(distL);
Serial.print(" | DD: "); Serial.print(distR);
Serial.print(" | DF: "); Serial.print(distD);
Serial.print(" | Servo: "); Serial.println(direccionServo.read());
